"""
Modal deployment for State Research Tracker.

Builds from GitHub main branch.
Deploy with: modal deploy modal_app.py
"""

import datetime
import modal

app = modal.App("state-research-tracker")

REPO_URL = "https://github.com/PolicyEngine/state-legislative-tracker.git"
BRANCH = "main"

# Bump this when source code changes to rebuild the app layer
APP_VERSION = "v21"

# Evaluated at deploy time — unique command string busts Modal's layer cache
_now = datetime.datetime.utcnow().isoformat()

SUPABASE_ANON_KEY = (
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZm"
    "Z25ncWxnZnN2cWFydGlsZnVsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg0MjQ4OTgsImV4c"
    "CI6MjA4NDAwMDg5OH0.FprGrDgkfT0j3nK51VGtCozs6y1pfhtZ07qDUHBm8Go"
)

# Image: two layers so prerender always runs fresh while app build stays cached
image = (
    modal.Image.debian_slim(python_version="3.11")
    .apt_install("curl", "ca-certificates", "git")
    .run_commands(
        # Install Node.js 20
        "curl -fsSL https://deb.nodesource.com/setup_20.x | bash -",
        "apt-get install -y nodejs",
    )
    .run_commands(
        # Layer 1: Clone, install, build — cached until APP_VERSION is bumped
        f"echo 'app-build: {APP_VERSION}'",
        f"git clone --branch {BRANCH} --single-branch {REPO_URL} /app",
        "cd /app && npm install --legacy-peer-deps",
        # Anon key is public (read-only, row-level security enforced)
        "cd /app && VITE_SUPABASE_URL=https://ffgngqlgfsvqartilful.supabase.co"
        f" VITE_SUPABASE_ANON_KEY={SUPABASE_ANON_KEY}"
        " VITE_POSTHOG_KEY=phc_jrd8DSkxBiB4qr7mxqzizIFh0sIIZ0mSNSNGepllyGx"
        " npm run build",
    )
    .run_commands(
        # Layer 2: Pre-render — cache-busted every deploy to pick up new bills
        f"echo 'prerender: {_now}'",
        f"cd /app && SUPABASE_ANON_KEY={SUPABASE_ANON_KEY}"
        " node scripts/prerender.mjs",
    )
    .pip_install("fastapi", "uvicorn", "aiofiles")
)


@app.function(
    image=image,
    allow_concurrent_inputs=100,
)
@modal.asgi_app(label="state-legislative-tracker")
def web():
    """Serve static files with FastAPI."""
    from fastapi import FastAPI
    from fastapi.staticfiles import StaticFiles
    from fastapi.responses import FileResponse, Response
    import json
    import os

    api = FastAPI()

    dist_path = "/app/dist"

    # Load valid routes generated by prerender script
    _routes_file = f"{dist_path}/_valid_routes.json"
    valid_routes = set(json.load(open(_routes_file))) if os.path.isfile(_routes_file) else set()

    # Serve static assets
    if os.path.exists(f"{dist_path}/assets"):
        api.mount("/assets", StaticFiles(directory=f"{dist_path}/assets"), name="assets")

    @api.get("/{full_path:path}")
    async def serve_spa(full_path: str):
        """Serve the SPA with proper 404s for invalid routes."""
        file_path = f"{dist_path}/{full_path}"

        # If it's a file that exists, serve it
        if os.path.isfile(file_path):
            return FileResponse(file_path)

        # Check for pre-rendered directory page (e.g. /GA or /GA/ga-sb168)
        index_path = f"{file_path}/index.html"
        if os.path.isfile(index_path):
            return FileResponse(index_path)

        # Root path — serve homepage
        if not full_path:
            return FileResponse(f"{dist_path}/index.html")

        # Check if route is valid (known state or state/bill-id)
        # Normalize: strip trailing slash, uppercase first segment for state match
        normalized = full_path.strip("/")
        parts = normalized.split("/")
        route_key = parts[0].upper() if len(parts) == 1 else f"{parts[0].upper()}/{parts[1]}"

        if route_key in valid_routes:
            return FileResponse(f"{dist_path}/index.html")

        # Invalid route — return 404
        return Response(status_code=404, content="Not Found")

    return api
